# [Silver II] 잃어버린 괄호 - 1541 

[문제 링크](https://www.acmicpc.net/problem/1541) 

### 성능 요약

메모리: 14192 KB, 시간: 104 ms

### 분류

수학, 그리디 알고리즘, 문자열, 파싱

### 제출 일자

2025년 9월 13일 23:58:08

### 문제 설명

<p>세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.</p>

<p>그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.</p>

<p>괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.</p>

### 출력 

 <p>첫째 줄에 정답을 출력한다.</p>

### 풀이
<pre>최솟값을 만들기 위해서는 최대한 큰 수를 빼주면 된다. 즉, 덧셈으로 더할 수 있는 수는 모두 더한뒤에 빼준다! 
- 뺄셈을 기준으로 문자열을 분리해준다.
- 덧셈은 먼저 더해준다.
- 각 더해진 값들을 다 빼준다
이때! 첫번째 값은 양수여야 한다. 가장 처음과 마지막 문자는 숫자라고 했으니 첫번째에 음수가 오는 경우는 없고, 첫번째 값부터 빼주면 첫번째 수도 음수가 되버리므로 잘못된 값이 계산된다.

<b>1번 방법 StringTokenizer로 쪼개기</b>
StringTokenizer subtraction = new StringTokenizer(br.readLine(), "-");
에서 sb에는 “-“기준으로 쪼개져서 토큰 단위로 저장된다. sb는 토큰들의 묶음이고(큐 처럼 꺼내 쓰는 구조) 예를 들어 55-50+40라는 문자열이 들어왔다면 “55” “50+40”으로 내부적으로 두 문자열을 가지고 있다. 

st.hasMoreTokens() : 아직 읽을 토큰이 있으면 true, 없으면 false


<b>2번 방법 split()으로 쪼개기</b>
여기서 split의 경우 정규식을 받기 때문에 “+”를 하면 regex.PatternSyntaxException을 뱉는데, +문자가 메타문자이기 때문이다.
그렇기 때문에 온전하게 문자 그자체로 이용하기 위해서는 이스케이프 처리를 해야한다. 이때 \(백슬래시)도 단독으로 출력할 수 없기때문에 백슬래시도 이스케이프 처리를 한다. 즉 \\+를 해야 한다.</pre>
