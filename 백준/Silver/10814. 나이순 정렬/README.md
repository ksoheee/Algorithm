# [Silver V] 나이순 정렬 - 10814 

[문제 링크](https://www.acmicpc.net/problem/10814) 

### 성능 요약

메모리: 137184 KB, 시간: 860 ms

### 분류

정렬, 집합과 맵

### 제출 일자

2025년 7월 3일 19:28:50

### 문제 설명

<p>온라인 저지에 가입한 사람들의 나이와 이름이 가입한 순서대로 주어진다. 이때, 회원들을 나이가 증가하는 순으로, 나이가 같으면 먼저 가입한 사람이 앞에 오는 순서로 정렬하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 온라인 저지 회원의 수 N이 주어진다. (1 ≤ N ≤ 100,000)</p>

<p>둘째 줄부터 N개의 줄에는 각 회원의 나이와 이름이 공백으로 구분되어 주어진다. 나이는 1보다 크거나 같으며, 200보다 작거나 같은 정수이고, 이름은 알파벳 대소문자로 이루어져 있고, 길이가 100보다 작거나 같은 문자열이다. 입력은 가입한 순서로 주어진다.</p>

### 출력 

 <p>첫째 줄부터 총 N개의 줄에 걸쳐 온라인 저지 회원을 나이 순, 나이가 같으면 가입한 순으로 한 줄에 한 명씩 나이와 이름을 공백으로 구분해 출력한다.</p>

### 풀이 1
<p>String[][]2차원 배열을 통해 각 배열에 나이와 이름을 저장한 뒤, 나이 순으로 정렬하는 방법</p>
<p>Arrays.sort()에 Comparatordml compare메소드를 구현하여 사용자 정렬을 사용해서 쓸 수 있다. 즉, 나이 순으로 정렬하되, 나이가 같을 경우는 0 이반환되어 자연스레 입력순으로 정렬된다. 람다식으로도 풀이 가능</p>

### 풀이 2
<p>배열을 이용하지 않고 클래스 객체를 만들어 배열처럼 사용하는 방법</p>
<p>Person클래스를 만들어서 나이와 이름을 변수로 받는 생성자를 만들고, 이 Person 클래스를 하나의 타입(=객체타입)으로 하여 배열을 생성해준 뒤, 해당 객체의 나이끼리 비교하여 정렬해주는 방식이다. 이 방식 또한 정렬 방법은 Arrays.sort()를 확장하여 정렬할 수 있다. toString()메서드는 객체를 출력할 때, 사용자의 읨의로 출력하고자 하는 문자열을 지정할 수 있다.</p>

### 풀이 3
<p>StringBuilder을 배열처럼 사용하여 Counting sort형태로 사용할 수 있다.</p>
<p>나이는 1이상 200이하이므로 201개의 StringBuilder배열을 만들면 된다. 위의 2번처럼 StringBuilder객체를 하나의 타입으로 받아서 사용할 수 있다. 또한 2번에 비해 더 좋은 점은 문자열을 append()하여 문자를 이을 수 있기 때문에 우리가 카운팅 정렬을 하듯이 나이를 기준으로 배열에 입력받으면서, 같은 나이일 경우 이미 해당 인덱스에 존재하던 문자열 뒤에 append()하여 이어주기만 하면 성능 측면에서도 매우 좋아진다. </p>

### 방법
<p>방법 1 : [String[][] + Scanner + System.out.println]</p>
<p>방법 1-1:  [String[][] + Scanner + System.out.println]+람다식</p>
<p>방법 2 : [String[][] + Scanner + StringBuilder]</p>
<p>방법 3 : [Person[] + Scanner + StringBuilder] </p>
<p>방법 4 ; [StringBuilder[] + Scanner + StringBuilder]</p>

### 비교
| 방법 번호   | 데이터 구조                  | 출력 방식                                          | 정렬 방식                                          | 장점                                                                                                  | 단점                                         |
| ------- | ----------------------- | ---------------------------------------------- | ---------------------------------------------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------ |
| **1**   | `String[][]`            | `for` 루프 안에서 `System.out.println`              | `Arrays.sort(String[][], Comparator)` (익명 클래스) | - 가장 간단한 형태<br>- 바로바로 출력해서 메모리 부담 적음                                                                | - 출력 호출(`println`)이 N번 발생 → I/O 오버헤드 큼     |
| **1-1** | `String[][]`            | `for` + `println`                              | `Arrays.sort(..., (a,b)->…)` (람다)              | - 익명 클래스보다 간결한 정렬 코드<br>- 가독성↑                                                                      | - 여전히 N번 `println`<br>- 데이터는 단순 2차원 배열 형태  |
| **2**   | `String[][]`            | `StringBuilder`에 모아서 한 번에 `System.out.println` | 익명 클래스                                         | - I/O 호출 횟수 1회로 줄여서 속도↑<br>- 코드 수정 시 출력 로직 집중 관리 가능                                                 | - 출력용 `StringBuilder`를 위한 추가 메모리 사용        |
| **3**   | `Person[]` (객체 배열)      | `StringBuilder` 모아서 한 번에 출력                    | `Arrays.sort(Person[], Comparator)`            | - `Person` 클래스에 `age`, `name` 필드를 명확히 분리<br>- OOP 원칙 준수<br>- 확장성↑<br>- `toString()` 오버라이드로 출력 형식 통일 | - 객체 생성 오버헤드 (new Person)                  |
| **4**   | `StringBuilder[]` (라인별) | `StringBuilder` 배열을 합쳐서 출력                     | 익명 클래스                                         | - 각 줄을 `StringBuilder` 자체로 저장 → 개별 문자열 빌드 빠름                                                        | - `StringBuilder` 객체 N개 생성 → 메모리·GC 오버헤드 큼 |


 ![image](https://github.com/user-attachments/assets/831431c7-3f07-410a-b9fe-0bb60e037dcd)


