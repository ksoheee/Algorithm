# [Silver II] 연속합 - 1912 

[문제 링크](https://www.acmicpc.net/problem/1912) 

### 성능 요약

메모리: 23308 KB, 시간: 224 ms

### 분류

다이나믹 프로그래밍, 최대 부분 배열 문제

### 제출 일자

2025년 12월 11일 20:41:50

### 문제 설명

<p>n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.</p>

<p>예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.</p>

### 입력 

 <p>첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</p>

### 출력 

 <p>첫째 줄에 답을 출력한다.</p>

### 풀이
<pre>연속된 값 중에 최대값이므로 이전 상태의 계산 결과에 직접 의존한다 =>dp

[상태]
dp[i][j] i부터 j까지 더한 값 (이때 i<=j) 

[점화식]
dp[i][j] = dp[i][j-1] + arr[i]

[초기값]
I=j 일때는 dp[i][j]= arr[i]

이렇게 풀면 n*n으로 dp가 아니다.(완전탐색)
—-------
[상태]
dp[i] = i번째 원소에서 끝나는 최대 부분 배열 합
=>다음 상태는 반드시 "i를 끝으로 한 값"에서만 확장되기 때문

[점화식]
i번째 원소에서 만들 수 있는 최대 부분 합은 두 가지이다.
현재수를 단독으로 쓰거나 이전 연속합에 현재 값을 이어붙이기 둘 중에 하나다
dp[i] = max(arr[i], dp[i-1] + arr[i])

[시간 복잡도]
배열 한번 순회 o(n)
dp는 dp[i-1]만 참고 o(1)</pre>

