# [Gold V] 숨바꼭질 3 - 13549 

[문제 링크](https://www.acmicpc.net/problem/13549) 

### 성능 요약

메모리: 15660 KB, 시간: 124 ms

### 분류

그래프 이론, 그래프 탐색, 너비 우선 탐색, 최단 경로, 데이크스트라, 0-1 너비 우선 탐색

### 제출 일자

2026년 1월 1일 16:22:29

### 문제 설명

<p>수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.</p>

<p>수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.</p>

### 출력 

 <p>수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.</p>

### 풀이
<pre>
<b>[알고리즘]</b>
3가지 할 수 있는 행동 중 에 어떤 행동을 하냐에 따라 다음 값이 영향을 미침 -> dp 인줄 알았지만,
dp는 작은 문제에서 큰문제로 확장되어야 하고(한 방향으로만 진행), 한번 정한 이전 값은 확정 되어야 한다 
하지만 이 문제는 왔다 갔다 양방향이 가능하고, 순간이동은 시간이 0초이기 때문에 더 멀리 갔다가 돌아오는게 더 빠를 수도 있으므로 값을 확정 할 수 없다 따라서 dp는 아니다!!
->Bfs로 풀어야 한다

일반 bfs의 전제는 모든 간선의 비용(보통1)이 동일하다는 것인데 여기서는 비용이 1초와 0초 두 가지 이다
일반 bfs에서는 간선의 비용이 동일하기 때문에 큐에 들어간 순서가 = 시간 순서 라고 가정하는데 여기서는 나중에 큐에 들어간 노드가 더 빠른 시간 일 수 있다
-> 먼저 방문 = 최단 시간 이라는 bfs의 성질이 성립하지 않는다

간선의 종류가 0과1 두 종류이기 때문에 탐색 우선순위를 조절하기 위해 deque를 사용한다
0초가 걸리는 탐색은 addFirst로 앞에 넣어서 먼저 탐색하게 하고 
1초가 걸리는 탐색은 addLast로 뒤에 넣어서 나중에 탐색하게 하면 
K까지 도달하는 가장 짧은 시간을 구할 수 있다.
(만약 간선의 종류가 2가지 보다 이상이라면 다익스트라를 이용해서 현개까지 가장 짧은 거리를 먼저 꺼내야 한다)

<b>[구현]</b>
deque을 이용해서 (위치,시간)을 함께 넣을 수는 있지만 
-> 어떤 위치 x에 나중에 더 짧은 시간으로 도달할 수 있기 때문에 큐에 처음 들어간 순간이 최단시간이 아닐 수 있다 
따라서 deque에는 위치만 넣고 최소 시간은 배열을 따로 만들어 관리해야한다

탐색은 순간이동, 전진,후진 3가지를 하면 되는데
순간이동은 비용이 0이기 때문에 순간이동을 해도 걸리는 시간이 변함 없으므로, 
순간이동한 위치 nx에 도달하는데 걸리는 최소 시간의 값이 현재 위치 x까지 도달하는데 걸리는 시간 보다 크다면 nx의 값을 새로운 최소시간으로 갱신한다
</pre>

